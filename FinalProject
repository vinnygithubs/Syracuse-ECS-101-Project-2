# Global Variables
import pandas as pd
XL = pd.read_excel('P2M012_G5.xlsx', dtype=str)
# Columns
Char = list(XL['Char'])
Bin = list(XL['Bin'])
Dec = list(XL['Dec'])

# Character replacements mapping
replacements = {
    '<space>': ' ',
    '<apostraphe>': "'",
    '\\n': "\n",
}

# Replace characters using the mapping
for ind, char in enumerate(Char):
    if char in replacements:
        Char[ind] = replacements[char]

key = dict(zip(Char, Bin))      # turns characters
    # zip function makes a dictionary  # into keys and
    # with two lists
#
ShortNum = 5
LongNum = 7
#

# Tanner Moore
# Encode Function
# Encode function translates a text file of characters
# into a text file of binary code containing the number
# of bits required to translate and the binary sequence.

def encode(fn):

    with open(fn, 'r') as f:
        fn = f.read()

    for old, new in replacements.items():
        fn = fn.replace(old, new)

    binary_file = ""
    ind = 0

    while ind < len(fn):
        found = False
        for i in range(4, 0, -1):
            if str(fn[ind: ind + i]) in key:
                binary_file += str(key[fn[ind: ind + i]])
                ind += i
                found = True
                break

        if not found:
            ind += 1

    newfile = str(len(binary_file)) + "." + binary_file
    # this creates the file sequence of D.B

    BinOutput = open("BinOutput.txt")
    with open('BinOutput.txt', 'w') as fileopen:
        fileopen.write(newfile)
    print("Encoded:", newfile)


# // ECS M012, Group 5 Decode File Function


def decode(fn="BinOutput.txt"):

    with open(fn, 'r') as f:
        fn = f.read()

    # WHILE THE FILE ISNT DECODED // LOOP
    currentspot = 0 # where we're at in the oldfile
    newfile = '' # the newfile str

    # LOOP THROUGH ALL NUMBERS BELOW
    while currentspot < len(fn):
        if fn[currentspot] == '0':
            char_in_binary = fn[currentspot:currentspot + ShortNum]
            row_index = XL[XL['Bin'] == char_in_binary].index
        elif fn[currentspot] == '1':
            char_in_binary = fn[currentspot:currentspot + LongNum]
            row_index = XL[XL['Bin'] == char_in_binary].index
        else:
            currentspot += 1
            continue

        if not row_index.empty:
            row = row_index[0]
            the_char = XL.loc[row, 'Char']
            newfile += replacements.get(the_char, the_char)
            currentspot += ShortNum if fn[currentspot] == '0' else LongNum

    TextOutput = open("TextOutput.txt")
    with open('TextOutput.txt', 'w') as fileopen:
        fileopen.write(newfile)
    print("Decoded:", newfile)

# Ashley Gottorff
# The same function compares the two text files and
# creates an errors file if the texts are different.
def same(fn1, fn2 = "TextOutput.txt"):
    f1 = open(fn1)
    text1 = f1.read()
    f1.close()
    print(text1)
# Reading in the content of text 2.
    f2 = open(fn2)
    text2 = f2.read()
    f2.close()
    print(text2)

    if text1 == text2:
        print("Identical Files")
    else:
        print("Different Files")
        # Create errors file.
        errors = open("Errors.txt", "w")
        # Write the lengths of the input files to
        # the errors file.
        L1 = len(text1)
        L2 = len(text2)
        errors.write("file 1: %d and file 2: %d\n" %(L1, L2))
        # Find the shortest length of the
        # two text strings.
        m = min(L1, L2)
        # Loop through all the functions
        # from 0 to the min length.
        for i in range(m):
           if text1[i] != text2[i]:
            errors.write("%d: %s: %s\n" %(i, text1[i], text2[i]))
        # Print extra characters to errors file.
        if L1 > L2:
            errors.write(text1[m:])
        elif L2 > L1:
            errors.write(text2[m:])
        errors.close()







